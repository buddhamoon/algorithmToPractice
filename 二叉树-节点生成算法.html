<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二叉树：节点生成算法</title>
</head>
<body>
    
    <!--

        二叉树节点生成函数
        功能描述：输入指定数字 ，生成对应节点数的二叉树。
        难点 ：
            1、创建出指定数量的节点 ，然后将这些节点按照二叉树的连接规则进行连接。

        实现思路：

        方法一 ：
            1、创建指定数目的节点层数 ，按照一定规则将节点循环挂载到对应节点的 left right 。
            2、一种较为简单的思路是，使用函数生成随机数，该随机数作为节点名称 ，这样只需要按照二叉树结构去挂载节点 ，不用担心节点重复。

        方法二 ：
            1、循环创建指定的节点数，并对应其节点名称为[1,2,3,4,5,...]
            2、这时候依次去挂载到二叉树上 ，这样做的一个难点在于 ，你如何让名称相同的节点不重复的挂载在二叉树上。

    -->


    <script>

        class AddNode {
            constructor ( value ) {
                if ( !value ) return;
                this.value = value;
                this.left = null;
                this.right = null;
            }

            conNode ( valone, valtwo ) {
                if ( !valone && !!this.left ) return;
                this.left = valone;
                if ( !valtwo && !!this.right ) return;
                this.right = valtwo;
            }
        };

        function guid() {
            return 'xxxxx-xxxx-xxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0,
                    v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // 方法 1：
        // 方法思路 ：建立指定的二叉树层级数量，然后使用生存随机节点（主要以节点名称区分）来挂载节点。
        function nodeTree_one ( num ) {
            if ( typeof(num) !== "number" || num < 1) return;
            class NodeAdd {
                constructor ( val ) {
                    this.value = val;
                    this.left = null;
                    this.right = null;
                };

                chlidNode ( val, num, max ) {
                    if ( num > max ) return;
                    // num ++;
                    if ( !val.left ) { 
                        val.left = new NodeAdd(guid())
                    } else { this.chlidNode (val.left, num, max) };
                    if ( !val.right ) { 
                        val.right = new NodeAdd(guid());
                    } else { this.chlidNode (val.right, num, max ) }
                    return val;
                }
            };
            let childLeft, childRight;
            const rootNode = new NodeAdd('root');
            for ( let i = 0; i < num; i ++ ) {
                rootNode.chlidNode( rootNode, i, num );
            };
            return rootNode;
        };

        // 生存一个 8 层的二叉树。
        const oneNodeVal = nodeTree_one (8);
        console.info( oneNodeVal );


        // 方法 2：
        function nodeTree ( num ) {
            // 严谨性校验
            if ( typeof(num) !== "number" || num < 1) return;
            // 创建指定数量的节点数组，供连接使用。
            const arr = [];
            for ( let i = 1; i < num + 1; i ++) {
                arr.push ( new AddNode (i) );
            };
            console.log(arr);

            // for ( let i = 0; i < arr.length; i++ ) {
            //     const nowNum = i;
            //     arr[i].conNode( arr[nowNum + 1], arr[nowNum + 2] );
            // };

            return arr[0];
        };
    </script>
</body>
</html>