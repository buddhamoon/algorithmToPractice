<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>只出现一次的数字</title>
</head>
<body>
    <!--

        给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

        说明：
        你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

        示例 1:
        输入: [2,2,1]
        输出: 1

        示例 2:
        输入: [4,1,2,1,2]
        输出: 4

    -->

    <script>
        /**
        * @param {number[]} nums
        * @return {number}
        */
        var singleNumber = function(nums) {
            for ( let i = 0; i < nums.length; i++ ){
                const value = nums[i];
                nums[i] = null;
                if ( !nums.includes(value) ) return value;
                nums[i] = value;
            }
        };

        /**
         * @param {number[]} nums
         * @return {number}
         * 执行用时：80 ms, 在所有 JavaScript 提交中击败了65.56%的用户
         * 内存消耗：43.3 MB, 在所有 JavaScript 提交中击败了9.17%的用户
         */
        var singleNumber_hashMap = function(nums) {
            const hashMap = {}
            for ( let i = 0; i < nums.length; i++ ){
                if ( nums[i] in hashMap ){
                    hashMap[nums[i]]++;
                } else {
                    hashMap[nums[i]] = 1;
                }
            }
            for ( let i in hashMap ){
                if (hashMap[i] === 1) return i;
            }
        };

        // 实际上，上面的两个算法都不能算是这一题的精髓解法

        /**
         * @param {number[]} nums
         * @return {number}
         */
        var singleNumber = function(nums) {
            return nums.reduce(( a, b ) => a ^ b );
        };
    </script>
</body>
</html>