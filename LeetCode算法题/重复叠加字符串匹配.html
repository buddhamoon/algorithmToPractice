<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>重复叠加字符串匹配</title>
</head>
<body>
    <!--

        给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。
        注意：字符串 "abc" 重复叠加 0 次是 ""，重复叠加 1 次是 "abc"，重复叠加 2 次是 "abcabc"。

        示例 1：
        输入：a = "abcd", b = "cdabcdab"
        输出：3
        解释：a 重复叠加三遍后为 "abcdabcdabcd", 此时 b 是其子串。

        示例 2：
        输入：a = "a", b = "aa"
        输出：2

        示例 3：
        输入：a = "a", b = "a"
        输出：1

        示例 4：
        输入：a = "abc", b = "wxyz"
        输出：-1
         
        提示：
        1 <= a.length <= 104
        1 <= b.length <= 104
        a 和 b 由小写英文字母组成

        解题小感：
            这道题虽然也被定义为难度中等，但整体从理解题意，到写出解题，只用了很少的时间，相对于前天的那道耗时几个小时的中等题，解题过程可谓差距极大。
            为什么会出现这种情况，其实无外乎两点：
            1、一些可能比较困难的方法，语言已经提供了你现成的方法，直接调用即可，屏蔽底层实现直接上层调用，本身就提高了效率。
            2、其实，决定一个问题是否难以被解决，多长时间被解决，并不完全取决于这个问题被定义为简单、中等、还是困难。
            而是取决于，这个问题所涉及的知识点，与你而言，掌握程度是多少 ？
            题目中所涉及到的知识点，你的熟练度越高，解题就越流畅。

    -->
    <script>
        /**
        * @param {string} a
        * @param {string} b
        * @return {number}
        * 执行用时：216 ms, 在所有 JavaScript 提交中击败了26.09%的用户
        * 内存消耗：43.1 MB, 在所有 JavaScript 提交中击败了10.87%的用户
        */
        var repeatedStringMatch = function(a, b) {
            if (!a.strCheck(b)) return -1;
            let str = '', count = 0;
            while (!str.includes(b)) {
                str += a;
                count++;
                if ( str.length > 10000 ) return -1;
            }
            return count;
            
        };

        // 判断指定字符串中的字符，是否都存在于当前字符串
        String.prototype.strCheck = function (str) {
            const arr = str.split('');
            return arr.every( item => {
                return this.includes(item);
            })
        }
    </script>
</body>
</html>