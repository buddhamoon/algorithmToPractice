<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>按照频率将数组升序排序</title>
</head>
<body>
    <!--

        给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。 
        请你返回排序后的数组。

        示例 1：
        输入：nums = [1,1,2,2,2,3]
        输出：[3,1,1,2,2,2]
        解释：'3' 频率为 1，'1' 频率为 2，'2' 频率为 3 。

        示例 2：
        输入：nums = [2,3,1,3,2]
        输出：[1,3,3,2,2]
        解释：'2' 和 '3' 频率都为 2 ，所以它们之间按照数值本身降序排序

        示例 3：
        输入：nums = [-1,1,-6,4,5,-6,1,4,1]
        输出：[5,-1,4,4,-6,-6,1,1,1]
         
        提示：
        1 <= nums.length <= 100
        -100 <= nums[i] <= 100

    -->

    <script>
        /**
        * @param {number[]} nums
        * @return {number[]}
        * 执行用时：76 ms, 在所有 JavaScript 提交中击败了99.37%的用户
        * 内存消耗：39.7 MB, 在所有 JavaScript 提交中击败了88.05%的用户
        */
        const test = [2,3,1,3,2];
        var frequencySort = function(nums) {
            const hash = {}, after = [], arr = [];
            nums.forEach( item => {
                if (item in hash){
                    hash[item]++;
                } else {
                    hash[item] = 1;
                }
            })
            for (let i in hash) {
                after.push({ index: hash[i], value: i });
            }
            // 这里在 sort 排序中做了特殊处理，因为当出现次数相同时，需要让原始值按照降序排列
            after.sort((a,b) => {
                if ( a['index'] == b['index']) return b['value'] - a['value'];
                return a['index'] - b['index'];
            });
            after.forEach( item => {
                for ( let i = 0; i < item['index']; i++){
                    arr.push(item['value'])
                }
            })
            return arr;
        };
        console.info(frequencySort(test));
    </script>
</body>
</html>