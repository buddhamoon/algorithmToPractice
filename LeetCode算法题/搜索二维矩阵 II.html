<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>搜索二维矩阵 II</title>
</head>
<body>
    
<!--

    编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：
    每行的元素从左到右升序排列。
    每列的元素从上到下升序排列。
     
    示例 1：
    输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
    输出：true

    示例 2：
    输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
    输出：false
     

    提示：
    m == matrix.length
    n == matrix[i].length
    1 <= n, m <= 300
    -109 <= matrix[i][j] <= 109
    每行的所有元素从左到右升序排列
    每列的所有元素从上到下升序排列
    -109 <= target <= 109

-->

<script>

    /**
    * @param {number[][]} matrix
    * @param {number} target
    * @return {boolean}
    * 中国好算法…… 
    * 通过 8320 ms  41.3 MB	JavaScript
    */
    var searchMatrix_one = function(matrix, target) {
        const len = matrix.length;
        for ( let i = 0; i < len / 2; i++ ) {
            if ( !!matrix[i].includes(target) ) return true;
            if ( !!matrix[len-1-i].includes(target)) return true;
        }
        return false;
    };

    /**
    * @param {number[][]} matrix
    * @param {number} target
    * @return {boolean}
    * 小的优化，略微提升，回避了一些不必要的 includes 调用
    * 通过 5636 ms 41.5 MB JavaScript
    */
    var searchMatrix = function(matrix, target) {
        const len = matrix.length;
        const twoLen = Math.round(len/2);
        for (let i = 0; i < twoLen; i++ ){
            if ( matrix[i][(matrix[i].length - 1)] >= target) {
                if ( !!matrix[i].includes(target) ) return true;
            };
            if ( matrix[len - 1 - i][0] <= target) {
                if ( !!matrix[len - 1 - i].includes(target) ) return true; 
            };
        } 
        return false;
    };

</script>

</body>
</html>